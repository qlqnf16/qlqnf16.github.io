---
layout: post

title: "트랜잭션"

categories: [computer-science, db]

date: 2019-10-10
---

트랜잭션에 대해 **깊게** 알아보자

---

일요일에 NHN 필기 시험을 보고 왔다. 준비를 하면서 막연하다는 느낌을 많이 받아서 힘들었는데, 공부한 것과 나온 문제가 잘 맞아서 그래도 잘 풀고 왔다. 물론 제대로 못 푼 문제도 많지만, 그중에서도 트랜잭션 문제가 기억에 남는다. 트랜잭션은 예전에 면접에서도 질문이 나왔어서 공부를 나름 열심히 해갔는데, 문제를 자신있게 풀 수가 없었다. 나는 트랜잭션의 기본적 특징과 연산 정도만 배워갔는데, 갑자기 **read committed, repeatable read** 같은 낯선 용어들이 등장했기 때문이다😞. 그래서 처음부터 작성해보는 _더 깊은 트랜잭션!_

# 트랜잭션

트랜잭션이란 데이터베이스나 그와 유사한 시스템에서 일어나는 상태 변환 과정의 작업 단위, 또는 **논리적 작업의 단위**이다. 이는 <u>하나의 작업을 수행하기 위한 일련의 연산</u>들로 이루어져 있다.

대표적인 예로 **[인터넷 뱅킹 송금]**이 있다. 내가 A라는 친구에게 송금을 한다면, 그 작업은 `내 계좌의 잔액 확인, 송금할 금액 차감 (-10000), 친구 계좌에 입금된 금액 더하기(+10000)` 등으로 이루어져 있을 것이다. 이 중 하나라도 제대로 이루어지지 않으면 이 작업은 성공했다고 볼 수 없다. 즉 하나의 작업이 완료되기 위한 연산의 묶음을 **트랜잭션**이라고 한다.

## 트랜잭션의 성질

인터넷 뱅킹 송금을 위해 필요한 여러 연산 중 하나라도 제대로 이루어지지 않으면 큰 문제가 생긴다. 친구에게 입금은 되지 않고 내 계좌에서 잔액만 빠져나가거나, 내 계좌에서 잔액이 빠지지 않은 채 입금만 되거나, 어느 쪽도 **절대로 일어나서는 안 된다**. 이를 방지하기 위한 트랜잭션의 성질이 몇 가지 있고, 이를 묶어 **ACID**라고 부르기도 한다.

- **원자성**(**A**tomicity)

> 트랜잭션의 연산은 데이터베이스에 모두 반영되든지, 모두 반영되지 않아야 한다.
>
> 트랜잭션의 연산은 모두가 완벽히 수행되어야 하며, 이 중 하나라도 실패하면 트랜잭션 전부가 취소되어야 한다.

- **일관성**(**C**onsistency)

> 트랜잭션의 실행이 성공적으로 완료되면 언제 어디서나 일관성 있는 데이터베이스 상태로 변화한다.
>
> 예를 들면, 송금의 경우 금액은 **언제나 Integer 타입을 유지**한다는 것이다. 이 타입은 갑자기 String이나 Bool로 변화하지 않고 언제나 Integer여야 한다.

- **격리성**(**I**solation)

> 둘 이상의 트랜잭션 수행 시 어느 하나의 트랜잭션 연산 수행 중 다른 트랜잭션이 끼어들지 못한다.
>
> 수행중인 트랜잭션은 수행이 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

- **영속성**(**D**urability)

> 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영원히 반영된다.

## 트랜잭션의 상태와 연산

#### 트랜잭션의 상태

![](https://doooyeon.github.io/assets/img/post/transaction-status.png)

- 활동(active): 트랜잭션이 실행중인 상태
- 실패(failed): 트랜잭션의 연산에 오류가 발생해 **일시적으로 중단**된 상태, 이 경우 **Rollback** 연산을 통해 트랜잭션을 철회(aborted)한다.
- 부분완료(Partially Committed): 트랜잭션의 <u>마지막 연산까지</u> 완료된 상태, 마지막 **commit** 연산 대기중.
- 완료(Commited): 트랜잭션이 **성공적으로 종료**되고 commit 연산이 완료된 상태.

#### 트랜잭션 연산

- commit: 하나의 트랜잭션이 완료되어 다시 데이터베이스가 일관된 상태에 있을 때, 트랜잭션이 완료되었음을 확인하는 연산
- rollback: 트랜잭션 실행 중 연산에 문제가 생겼을 때, **기존에 완료됐던 연산까지 모두 실행 취소**하고 트랜잭션이 시작되기 전으로 되돌리는 연산. 그 이후 해당 트랜잭션을 폐기하거나 재시작한다.

## 트랜잭션 격리 수준(Isolation Level)

트랜잭션의 성질 ACID 중, 격리성(Isolation)에서 파생되는 문제점이 있다. **격리성을 완벽히 유지하기 위해 모든 트랜잭션을 순차적으로 수행하면 동시성 처리 이슈가 발생하고, 동시성을 높이기 위해 병렬 처리를 허용하면 격리성이 침범당할 수 있다**는 것이다. 병렬처리를 할 때 생기는 격리성 이슈는 다음과 같다.

- Dirty Read

  한 트랜잭션(T1)이 데이터에 접근하여 값을 'A'에서 'B'로 변경했고 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이터를 Read 하면?
  T2가 읽은 데이터는 B가 될 것이다. 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이터는 꼬이게 된다.

- Non-Repeatable Read

  한 트랜잭션(T1)이 데이터를 **Read** 하고 있다. 이때 다른 트랜잭션(T2)가 데이터에 접근하여 값을 변경하거나 데이터를 삭제하고 커밋을 해버리면?

  그 후 T1이 다시 해당 데이터를 Read하고자 하면 변경되거나 사라진 데이터를 찾게 된다.

- Phantom Read

  트랜잭션(T1) 중에 특정 조건으로 데이터를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이터 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이터를 조회 하면 T2에서 추가/삭제된 데이터가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이터가 꼬인다

### 트랜잭션 격리 수준

위와 같은 문제점을 해결하기 위해 ANSI 표준에서 트랜잭션의 격리성과 동시 처리 성능에 관한 네 가지 격리 단계를 만들었다. 단계가 높아질 수록 격리성이 높아져 격리성 관련 문제가 발생할 확률은 줄어들지만, 처리 속도는 느려진다.

1. Read Uncommitted: 커밋하지 않은 데이터를 읽을 수 있다.

   한 트랜잭션(T1)이 데이터를 수정하고 커밋하기 전에 다른 트랜잭션이 그 데이터를 읽을 수 있다. 위에 언급된 모든 격리성 문제가 발생할 수 있으며, 따라서 RDBMS 표준에서는 격리성 수준으로 인정하지도 않는다고 한다.

2. **Read Committed**: 커밋이 완료된 데이터만 읽을 수 있다.

   한 트랜잭션(T1)이 데이터를 수정하고 커밋하기 전에 다른 트랜잭션(T2)이 그 데이터에 접근하면 **수정되기 전 값**을 받아본다. Dirty Read 문제가 해결된다. 그러나 T1 이 수행 중일 때 T2가 한 번 read를 하고, T1이 커밋된 후 T2가 다시 read 하면 그 값이 바뀌므로 non-repeatable read 문제는 해결되지 않는다.

   오라클 DBMS가 기본으로 채택하고 있고, **온라인 서비스에서 가장 많이 사용된다.**

3. **Repeatable Read**: 트랜잭션 내에서 한 번 조회한 데이터를 반복해 조회해도 같은 값을 얻을 수 있다.

   한 트랜잭션이 **이미 읽은 데이터는** 그 트랜잭션이 끝나기 전까지 **다른 트랜잭션이 변경 또는 삭제할 수 없다**. 동일 테이블에 다른 데이터가 추가될 수는 있지만, 조회된 열이 변경/삭제될 수는 없다.

   Mysql 의 InnoDB 스토리지 엔진이 기본으로 채택하고 있다.

4. Serializable: 가장 엄격한 격리수준. 격리성에 관련된 모든 문제를 방지할 수 있으나 동시처리성능은 떨어진다.

### 참고 자료

> - [[DB이론] 트랜잭션](https://victorydntmd.tistory.com/129)
> - [Isolation Levels in the Database Engine](<https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms189122(v=sql.105)?redirectedfrom=MSDN>)
> - [트랜잭션, 트랜잭션 격리수준(Isolation Level)](https://feco.tistory.com/45)
